use Into;
use rand::{Rng, Rand};
use std::num::Int;
use std::marker;
use std::ops::{RangeFull, Range, RangeFrom, RangeTo};

/// Type that can be used to create a random instance of `Output`.
///
/// Since no state is recorded, each sample is (statistically)
/// independent of all others, assuming the `Rng` used has this
/// property.
pub trait Distribution {
    /// The type that this trait is produced by sampling from this distribution.
    type Item;
    /// Generate a random value of `Item`, using `rng` as the
    /// source of randomness.
    fn sample<R: Rng>(&self, rng: &mut R) -> <Self as Distribution>::Item;
}

/// Data types that have a default distribution for generating random values.
///
/// For example for integers, the default distribution is a uniform distribution over all possible
/// values.
pub trait DefaultDistribution {
    /// The type of the default distribution for this type.
    type Distribution: Distribution<Item=Self>;

    fn default_distribution() -> <Self as DefaultDistribution>::Distribution;
}

/// Data types that can be created randomly.
///
/// This is a replacement for the current `Rand` trait.
pub trait Random {
    fn random<R: Rng>(rng: &mut R) -> Self;
}

impl <T> Random for T where T: DefaultDistribution
{
    fn random<R: Rng>(rng: &mut R) -> Self {
        T::default_distribution().sample(rng)
    }
}

/// Data types that can be converted into a `Distribution` over type `T`.
///
/// This trait is a little different from a normal `Into` trait because the type parameter
/// isn't the type of the `Distribution` being converted into, but the type that is generated by
/// that distribution.  This is so that `gen(&mut rng, ..) -> T` will work without additional type
/// annotations for the distribution.
pub trait IntoDistribution<T> {
    type Distribution: Distribution<Item=T>;

    fn into_distribution(self) -> <Self as IntoDistribution<T>>::Distribution;
}


/// Create a single random value by sampling from a distribution.
pub fn gen<T, IntoD: IntoDistribution<T>, R: Rng>(rng: &mut R, distribution_like: IntoD)
    -> <<IntoD as IntoDistribution<T>>::Distribution as Distribution>::Item
{
    distribution_like.into_distribution().sample(rng)
}

/// Generate an infinite stream of random values from a distribution.
fn gen_iter<T, IntoD: IntoDistribution<T>, R: Rng>(rng: R, distribution_like: IntoD) -> GenIter<R, <IntoD as IntoDistribution<T>>::Distribution> {
    GenIter {
        rng: rng,
        distribution: distribution_like.into_distribution(),
    }
}

/// Generate an infinite stream of random values from a distribution.
///
/// Takes a mutable reference to an Rng.  This is what would actually be used, but `gen_iter` is
/// used for benchmarking for similarity with the other approaches.
fn gen_iter_<'a, T, IntoD: IntoDistribution<T>, R: Rng>(rng: &'a mut R, distribution_like: IntoD) -> GenIter_<'a, R, <IntoD as IntoDistribution<T>>::Distribution> {
    GenIter_ {
        rng: rng,
        distribution: distribution_like.into_distribution(),
    }
}

pub struct GenIter<R, D> {
    rng: R,
    distribution: D
}

impl <R, D> Iterator for GenIter<R, D> where R: Rng, D: Distribution {
    type Item = <D as Distribution>::Item;

    fn next(&mut self) -> Option<<D as Distribution>::Item> {
        Some(self.distribution.sample(&mut self.rng))
    }
}

struct GenIter_<'a, R, D> where R: 'a, D:'a {
    rng: &'a mut R,
    distribution: D
}

impl <'a, R, D> Iterator for GenIter_<'a, R, D> where R: 'a + Rng, D: 'a + Distribution {
    type Item = <D as Distribution>::Item;

    fn next(&mut self) -> Option<<D as Distribution>::Item> {
        Some(self.distribution.sample(self.rng))
    }
}

// An impl for a reference to a distribution because 'gen' and 'gen_iter' above consume
// distributions.  This way you can pass a reference to a distribution to 'gen' and 'gen_iter'.
impl <'a, D> Distribution for &'a D where D: Distribution {
    type Item = <D as Distribution>::Item;

    fn sample<R: Rng>(&self, rng: &mut R) -> <Self as Distribution>::Item {
        (*self).sample(rng)
    }
}

pub struct UniformUnboundedIntegerRange<X> {
    _marker: marker::PhantomData<fn() -> X>,
}

impl <X: Int + Rand> UniformUnboundedIntegerRange<X> {
    pub fn new() -> UniformUnboundedIntegerRange<X> {
        UniformUnboundedIntegerRange { _marker: marker::PhantomData }
    }
}

impl <X: Int + Rand> Distribution for UniformUnboundedIntegerRange<X> {
    type Item = X;

    fn sample<R: Rng>(&self, rng: &mut R) -> X {
        Rand::rand(rng)
    }
}

// This only exists so that UniformIntegerRange can get an unbounded random integer.
// In an actual implementation, we would implement DefaultDistribution for all integers.
impl <X: Int + Rand> DefaultDistribution for X {
    type Distribution = UniformUnboundedIntegerRange<X>;

    fn default_distribution() -> UniformUnboundedIntegerRange<X> {
        UniformUnboundedIntegerRange::new()
    }
}

pub struct UniformIntegerRange<X> {
    low: X,
    range: X,
    accept_zone: X
}

impl <X: Int> UniformIntegerRange<X> {
    fn new(low: X, high: X) -> UniformIntegerRange<X> {
        assert!(low < high);
        let range = high.wrapping_sub(low);
        let max = Int::max_value();
        let zone = max - (max % range);

        UniformIntegerRange {
            low: low,
            range: range,
            accept_zone: zone,
        }
    }
}

impl <X: Int + Rand> Distribution for UniformIntegerRange<X> {
    type Item = X;

    fn sample<R: Rng>(&self, rng: &mut R) -> X {
        loop {
            let v: X = Rand::rand(rng);

            if v < self.accept_zone {
                return self.low.wrapping_add((v % self.range));
            }
        }
    }
}

impl <X: Int + Rand> IntoDistribution<X> for Range<X> {
    type Distribution = UniformIntegerRange<X>;

    fn into_distribution(self) -> UniformIntegerRange<X> {
        UniformIntegerRange::new(self.start, self.end)
    }
}

impl <X: Int + Rand> IntoDistribution<X> for RangeFull {
    type Distribution = UniformUnboundedIntegerRange<X>;

    fn into_distribution(self) -> UniformUnboundedIntegerRange<X> {
        UniformUnboundedIntegerRange::new()
    }
}

impl <T, D: Distribution<Item=T>> IntoDistribution<T> for D {
    type Distribution = D;

    fn into_distribution(self) -> Self {
        self
    }
}

#[cfg(test)]
use rand;

#[cfg(test)]
use test::{Bencher, black_box};

#[test]
fn test_generate_u8() {
    let mut rng: rand::XorShiftRng = rand::random();

    let u: u8 = gen(&mut rng, 1..10);
    let u: u8 = gen(&mut rng, ..);
}

#[bench]
fn iter(b: &mut Bencher) {
    let rng: rand::XorShiftRng = rand::random();

    b.iter(|| {
        for x in black_box(gen_iter::<u32, _, _>(rng.clone(), ..).take(100)) {
            black_box(x);
        }
    })
}

#[bench]
fn iter__noiterbb(b: &mut Bencher) {
    let rng: rand::XorShiftRng = rand::random();

    b.iter(|| {
        for x in (gen_iter::<u32, _, _>(rng.clone(), ..).take(100)) {
            black_box(x);
        }
    })
}

#[bench]
fn range_iter__bb(b: &mut Bencher) {
    let rng: rand::XorShiftRng = rand::random();

    b.iter(|| {
        for x in black_box(gen_iter::<u32, _, _>(rng.clone(), black_box(4..321)).take(100)) {
            black_box(x);
        }
    })
}

#[bench]
fn range_iter(b: &mut Bencher) {
    let rng: rand::XorShiftRng = rand::random();

    b.iter(|| {
        for x in black_box(gen_iter::<u32, _, _>(rng.clone(), 4..321).take(100)) {
            black_box(x);
        }
    })
}

#[bench]
fn range_iter__noiterbb(b: &mut Bencher) {
    let rng: rand::XorShiftRng = rand::random();

    b.iter(|| {
        for x in (gen_iter::<u32, _, _>(rng.clone(), 4..321).take(100)) {
            black_box(x);
        }
    })
}

#[bench]
fn gen_(b: &mut Bencher) {
    let mut rng: rand::XorShiftRng = rand::random();

    b.iter(|| {
        for _ in 4..321 {
            black_box(gen::<u32, _, _>(&mut rng, ..));
        }
    })
}

#[bench]
fn range_gen__bb(b: &mut Bencher) {
    let mut rng: rand::XorShiftRng = rand::random();

    b.iter(|| {
        for _ in 4..321 {
            black_box(gen::<u32, _, _>(&mut rng, black_box(4..321)));
        }
    })
}

#[bench]
fn range_gen(b: &mut Bencher) {
    let mut rng: rand::XorShiftRng = rand::random();

    b.iter(|| {
        for _ in 4..321 {
            black_box(gen::<u32, _, _>(&mut rng, (4..321)));
        }
    })
}
